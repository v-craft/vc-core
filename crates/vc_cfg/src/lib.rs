//! Some macros used for compilation control.
//!
//! # Example
//!
//! ```
//! # #![expect(unexpected_cfgs, reason = "doc-test")]
//! use vc_cfg;
//!
//! mod cfg {
//!     pub use vc_cfg::switch;
//!     // Define aliases for compilation options.
//!     vc_cfg::define_alias!{
//!         #[cfg(feature = "std")] => std,
//!     }
//! }
//!
//! // As a Boolean literal, with empty content
//! fn std_is_enabled() -> bool {
//!     cfg::std!()
//! }
//!
//! // Control whether the internal codes are effective.
//! cfg::std!{
//!     extern crate std;
//! }
//!
//! // Branch
//! cfg::std!{
//!     if {
//!         mod std_impls{ /* ... */}
//!     } else {
//!         mod no_std_impls{ /* ... */}
//!     }
//! }
//!
//! // Switch-like
//! cfg::switch!{
//!     cfg::std => {
//!         mod std_impl{ /* .. */ }
//!     }
//!     #[cfg(debug_assertions)] => {
//!         mod debug_impl{ /* .. */ }
//!     }
//!     _ => {
//!         /* ... */
//!     }
//! }
//! ```
//!
//! See more infomations in:
//! - [`disabled`]: Indicates compilation options that are not enabled.
//! - [`enabled`]: Indicates compilation options that are enabled.
//! - [`switch`]: Blocks similar to 'switch'.
//! - [`define_alias`]: Define aliases for compilation options.
//!
//! [`disabled`]: crate::disabled
//! [`enabled`]: crate::enabled
//! [`switch`]: crate::switch
//! [`define_alias`]: crate::define_alias
#![cfg_attr(docsrs, feature(doc_cfg))]
#![no_std]

// -----------------------------------------------------------------------------
// Macros

/// Represents a disabled conditional compilation block.
///
/// # Example
///
/// ```
/// use vc_cfg as cfg;
///
/// let mut x = 0;
///
/// // empty -> false
/// assert!( !cfg::disabled!() );
///
/// // if { A } else { B } -> B
/// cfg::disabled!(
///     if {
///         panic!();
///     } else {
///         x += 1;
///     }
/// );
///
/// // A -> empty (do nothing)
/// cfg::disabled!{ x += 10; };
/// assert_eq!(x, 1);
/// ```
#[macro_export]
macro_rules! disabled {
    () => { false };
    (if { $($p:tt)* } else { $($n:tt)* }) => { $($n)* };
    ($($p:tt)*) => {};
}

/// Represent a enabled condition compilation block.
///
/// # Example
///
/// ```
/// use vc_cfg as cfg;
///
/// let mut x = 0;
///
/// // empty -> true
/// assert!( cfg::enabled!() );
///
/// // if { A } else { B } -> A
/// cfg::enabled!(
///     if {
///         x += 1;
///     } else {
///         panic!();
///     }
/// );
///
/// // A -> A
/// cfg::enabled!{ x += 10; };
/// assert_eq!(x, 11);
/// ```
#[macro_export]
macro_rules! enabled {
    () => { true };
    (if { $($p:tt)* } else { $($n:tt)* }) => { $($p)* };
    ($($p:tt)*) => { $($p)* };
}

/// A conditional compilation macro similar to `switch` .
///
/// # Example
///
/// ```
/// use vc_cfg as cfg;
///
/// let mut x = 0;
/// cfg::switch! {
///     #[cfg(test)] => {
///         x += 1;
///     }
///     cfg::enabled => {
///         x += 10;
///     }
///     _ => {
///         x += 100;
///     }
/// }
/// assert!(x == 1 || x == 10);
/// ```
#[macro_export]
macro_rules! switch {
    (_ => { $($output:tt)* } $(,)?) => {
        $($output)*
    };
    ($cond:path => { $($output:tt)* } $(,)?) => {
        $($output)*
    };
    (#[cfg($cfg:meta)] => { $($output:tt)* } $(,)?) => {
        #[cfg($cfg)] $crate::switch! { _ => { $($output)* } }
    };
    ( $cond:path => { $($output:tt)* } , $( $rest:tt )+ ) => {
        $cond! { if { $($output)* } else { $crate::switch! { $($rest)+ } } }
    };
    ( $cond:path => { $($output:tt)* } $( $rest:tt )+ ) => {
        $cond! { if { $($output)* } else { $crate::switch! { $($rest)+ } } }
    };
    ( #[cfg($cfg:meta)] => { $($output:tt)* } , $( $rest:tt )+ ) => {
        #[cfg($cfg)] $crate::switch! { _ => { $($output)* } }
        #[cfg(not($cfg))] $crate::switch! { $($rest)+ }
    };
    ( #[cfg($cfg:meta)] => { $($output:tt)* } $( $rest:tt )+ ) => {
        #[cfg($cfg)] $crate::switch! { _ => { $($output)* } }
        #[cfg(not($cfg))] $crate::switch! { $($rest)+ }
    };
}

/// Define aliases for compilation options.
///
/// The alias generated by this macro is equivalent to [`enabled`] or [`disabled`] ,
/// depending on whether the compilation conditions are valid.
///
/// ## Example
///
/// ```
/// use vc_cfg as cfg;
///
/// cfg::define_alias!{
///     #[cfg(test)] => enable_test,
/// };
///
/// // `enable_test` is eq to 'cfg::enabled' in testing.
/// // Otherwise it is eq to 'cfg::disabled'.
/// let mut x = false;
/// enable_test!{ x = true; };
///
/// // Docs test is not Unit Test.
/// // So `enable_test!` is eq to 'cfg::disabled'.
/// assert!(x == false);
/// ```
#[macro_export]
macro_rules! define_alias {
    ( #[cfg($meta:meta)] => { $(#[$id_meta:meta])* $id:ident } $(,)? ) => {
        $crate::switch! {
            #[cfg($meta)] => {
                #[doc = concat!("An alias for `vc_cfg::enabled` or `vc_cfg::disabled` .\n\n")]
                #[doc = concat!("If `#[cfg(", stringify!($meta), ")]` is active, this is `enabled`. Otherwise, this is `disabled`.")]
                $(#[$id_meta])*
                pub use $crate::enabled as $id;
            }
            _ => {
                #[doc = concat!("An alias for `vc_cfg::enabled` or `vc_cfg::disabled` .\n\n")]
                #[doc = concat!("If `#[cfg(", stringify!($meta), ")]` is active, this is `enabled`. Otherwise, this is `disabled`.")]
                $(#[$id_meta])*
                pub use $crate::disabled as $id;
            }
        }
    };
    ( #[cfg($meta:meta)] => $id:ident $(,)? ) => {
        $crate::define_alias! { #[cfg($meta)] => { $id } }
    };
    ( #[cfg($meta:meta)] => $id:ident , $( $rest:tt )+ ) => {
        $crate::define_alias! { #[cfg($meta)] => { $id } }
        $crate::define_alias! { $( $rest )+ }
    };
    ( #[cfg($meta:meta)] => { $(#[$id_meta:meta])* $id:ident } , $( $rest:tt )+ ) => {
        $crate::define_alias! { #[cfg($meta)] => { $(#[$id_meta])* $id } }
        $crate::define_alias! { $($rest)+ }
    };
    ( #[cfg($meta:meta)] => { $(#[$id_meta:meta])* $id:ident } $( $rest:tt )+ ) => {
        $crate::define_alias! { #[cfg($meta)] => { $(#[$id_meta])* $id } }
        $crate::define_alias! { $($rest)+ }
    };
}
