//! Some macros used for compilation control.
//!
//! # Example
//!
//! ```
//! use vc_cfg as cfg;
//!
//! // Define aliases for compilation options.
//! cfg::define_alias!{
//!     #[cfg(feature = "std")] => std,
//! }
//!
//! // As a Boolean literal
//! fn std_is_enabled() -> bool {
//!     cfg::std!()
//! }
//!
//! // Control whether the internal codes are effective.
//! cfg::std!{
//!     extern crate std;
//! }
//! ```
//!
//! See more infomations in:
//! - [`disabled`]: Indicates compilation options that are not enabled.
//! - [`enabled`]: Indicates compilation options that are enabled.
//! - [`switch`]: Blocks similar to 'switch'.
//! - [`define_alias`]: Define aliases for compilation options.
#![cfg_attr(docsrs, feature(doc_cfg))]
#![no_std]

/// Represents a disabled conditional compilation block.
///
/// # Example
///
/// ```
/// use vc_cfg as cfg;
///
/// let mut x = 0;
///
/// // empty -> false
/// assert!( !cfg::disabled!() );
///
/// // if { A } else { B } -> B
/// cfg::disabled!(
///     if {
///         panic!();
///     } else {
///         x += 1;
///     }
/// );
///
/// // A -> empty (do nothing)
/// cfg::disabled!{ x += 10; };
/// assert_eq!(x, 1);
/// ```
#[macro_export]
macro_rules! disabled {
    () => { false };
    (if { $($p:tt)* } else { $($n:tt)* }) => { $($n)* };
    ($($p:tt)*) => {};
}

/// Represent a enabled condition compilation block.
///
/// # Example
///
/// ```
/// use vc_cfg as cfg;
///
/// let mut x = 0;
///
/// // empty -> true
/// assert!( cfg::enabled!() );
///
/// // if { A } else { B } -> A
/// cfg::enabled!(
///     if {
///         x += 1;
///     } else {
///         panic!();
///     }
/// );
///
/// // A -> A
/// cfg::enabled!{ x += 10; };
/// assert_eq!(x, 11);
/// ```
#[macro_export]
macro_rules! enabled {
    () => { true };
    (if { $($p:tt)* } else { $($n:tt)* }) => { $($p)* };
    ($($p:tt)*) => { $($p)* };
}

/// A conditional compilation macro similar to `switch` .
///
/// Internal `{}` is not allowed to be followed by `,` .
///
/// # Example
///
/// ```
/// use vc_cfg as cfg;
///
/// let mut x = 0;
/// cfg::switch! {
///     #[cfg(test)] => {
///         x += 1;
///     }
///     cfg::enabled => {
///         x += 10;
///     }
///     _ => {
///         x += 100;
///     }
/// }
/// assert!(x == 1 || x == 10);
/// ```
#[macro_export]
macro_rules! switch {
    (_ => { $($output:tt)* }) => {
        $($output)*
    };
    (
        $cond:path => $output:tt
        $($( $rest:tt )+)?
    ) => {
        $cond! {
            if {
                $crate::switch! { _ => $output }
            } else {
                $(
                    $crate::switch! { $($rest)+ }
                )?
            }
        }
    };
    (
        #[cfg($cfg:meta)] => $output:tt
        $($( $rest:tt )+)?
    ) => {
        #[cfg($cfg)]
        $crate::switch! { _ => $output }
        $(
            #[cfg(not($cfg))]
            $crate::switch! { $($rest)+ }
        )?
    }
}

/// Define aliases for compilation options.
///
/// The alias generated by this macro is equivalent to [`enabled`] or [`disabled`] ,
/// depending on whether the compilation conditions are valid.
///
/// Internal `{}` is not allowed to be followed by `,` .
///
/// ## Example
///
/// ```
/// use vc_cfg as cfg;
///
/// cfg::define_alias!{
///     #[cfg(test)] => enable_test,
/// };
///
/// // `enable_test` is eq to 'cfg::enabled' in testing.
/// // Otherwise it is eq to 'cfg::disabled'.
/// let mut x = false;
/// enable_test!{ x = true; };
///
/// // Docs test is not Unit Test.
/// // So `enable_test!` is eq to 'cfg::disabled'.
/// assert!(x == false);
/// ```
#[macro_export]
macro_rules! define_alias {
    (
        #[cfg($meta:meta)] => $p:ident
        $(, $( $rest:tt )+)?
    ) => {
        $crate::define_alias! {
            #[cfg($meta)] => { $p }
            $( $($rest)+ )?
        }
    };
    (
        #[cfg($meta:meta)] => $p:ident,
    ) => {
        $crate::define_alias! {
            #[cfg($meta)] => { $p }
        }
    };
    (
        #[cfg($meta:meta)] => {
            $(#[$id_meta:meta])*
            $id:ident
        }
        $($( $rest:tt )+)?
    ) => {
        $crate::switch! {
            #[cfg($meta)] => {
                #[doc = concat!("An alias for `vc_cfg::enabled` or `vc_cfg::disabled` .\n\n")]
                #[doc = concat!("If `#[cfg(", stringify!($meta), ")]` is active, this is `enabled`. Otherwise, this is `disabled`.")]
                $(#[$id_meta])*
                pub use $crate::enabled as $id;
            }
            _ => {
                #[doc = concat!("An alias for `vc_cfg::enabled` or `vc_cfg::disabled` .\n\n")]
                #[doc = concat!("If `#[cfg(", stringify!($meta), ")]` is active, this is `enabled`. Otherwise, this is `disabled`.")]
                $(#[$id_meta])*
                pub use $crate::disabled as $id;
            }
        }

        $(
            $crate::define_alias! {
                $($rest)+
            }
        )?
    }
}

define_alias! {
    #[cfg(feature = "std")] => std,
    #[cfg(panic = "unwind")] => panic_unwind,
    #[cfg(panic = "abort")] => panic_abort,
}
