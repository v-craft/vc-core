//! Contents provided to proc macros.
//!
//! Users should not directly use any content here.

// -----------------------------------------------------------------------------
// Macro tools

/// A internal module provided for proc-macro implementation.
pub mod macro_utils {
    // When generating code, using `std` or `alloc` directly is unsafe.
    // Users may be in a `no_std` env or not displaying imported `alloc`.
    //
    // Therefore, proc-macro crate will use this path.
    pub use ::alloc::{
        borrow::{Cow, ToOwned},
        boxed::Box,
        string::ToString,
    };

    // An efficient string concatenation function.
    pub use crate::impls::concat as __concat;

    // use for `reflect_clone` impl
    pub fn __reflect_clone_field<T: crate::Reflect + crate::info::TypePath>(
        source: &T,
    ) -> Result<T, crate::ops::ReflectCloneError> {
        if let Ok(t) = source.reflect_clone()
            && let Ok(val) = t.take::<T>()
        {
            Ok(val)
        } else {
            Err(crate::ops::ReflectCloneError::NotSupport {
                type_path: T::type_path().into(),
            })
        }
    }
}

// -----------------------------------------------------------------------------
// auto_register support

/// A internal module provided for auto_register implementation.
#[cfg(feature = "auto_register")]
pub mod auto_register {
    use crate::derive::Reflect;
    use crate::registry::{GetTypeMeta, TypeMeta, TypeRegistry};

    /// We use `inventory` crate to implement static registration.
    pub use inventory;

    /// We will collect all registration function through this wrapper.
    pub struct __AutoRegisterFunc(pub fn(&mut TypeRegistry));

    inventory::collect!(__AutoRegisterFunc);

    /// A trait that provides registration function for collector.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// inventory::submit!{
    ///     __AutoRegisterFunc(
    ///         <MyStruct as __RegisterType>::__register
    ///     )
    /// }
    /// ```
    pub trait __RegisterType {
        fn __register(_registry: &mut TypeRegistry) {}
    }

    impl<T: GetTypeMeta> __RegisterType for T {
        fn __register(registry: &mut TypeRegistry) {
            registry.register::<T>();
        }
    }

    /// A register function provides for [`TypeRegistry::auto_register`].
    pub fn __register_types(registry: &mut TypeRegistry) {
        #[cfg(target_family = "wasm")]
        wasm_support::init();
        // Call all registration functions collected by inventory crate.
        for registry_fn in inventory::iter::<__AutoRegisterFunc> {
            registry_fn.0(registry);
        }
    }

    #[cfg(target_family = "wasm")]
    mod wasm_support {
        use vc_os::sync::Once;

        #[expect(unsafe_code, reason = "This function is generated by linker.")]
        unsafe extern "C" {
            fn __wasm_call_ctors();
        }

        /// This function must be called before using [`inventory::iter`]
        /// on [`AutomaticReflectRegistrations`] to run constructors on all platforms.
        pub fn init() {
            static ONCE: Once = Once::new();
            // SAFETY:
            // This will call constructors on wasm platforms at most once.
            //
            // See: https://docs.rs/inventory/latest/inventory/#webassembly-and-constructors
            #[expect(unsafe_code, reason = "This function must be called to on wasm.")]
            ONCE.call_once(|| unsafe {
                __wasm_call_ctors();
            });
        }
    }

    /// For checking if automatic registration is working properly.
    ///
    /// Provided for [`TypeRegistry::auto_register`].
    #[derive(Reflect)]
    #[reflect(auto_register)]
    #[reflect(GetTypeMeta = false, FromReflect = false)]
    pub struct __AvailFlag;

    impl GetTypeMeta for __AvailFlag {
        fn get_type_meta() -> TypeMeta {
            TypeMeta::of::<Self>()
        }
    }
}
