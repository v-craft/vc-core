use alloc::boxed::Box;
use core::any::{Any, TypeId};

use crate::info::{DynamicTypePath, TypePath};

/// A abstract trait representing the capabilities supported by a type.
///
/// `TypeTrait` can be registered to the [`TypeRegistry`] and stored on a type's [`TypeMeta`](crate::registry::TypeMeta).
///
/// Almost any type that implements [`Clone`] and [`TypePath`] can be considered "type trait".
/// This is because it has a blanket implementation over all `T` where `T: TypePath + Clone + Send + Sync + 'static`.
///
/// While custom type trait is often generated using the [`#[reflect_trait]`](crate::derive::reflect_trait) macro.
///
/// # Naming Convention
///
/// We provided some `TypeTrait`s with `TypeTrait` prefix, such as:
/// - [`TypeTraitDefault`](crate::registry::TypeTraitDefault)
/// - [`TypeTraitFromPtr`](crate::registry::TypeTraitFromPtr)
/// - [`TypeTraitFromReflect`](crate::registry::TypeTraitFromReflect)
/// - [`TypeTraitSerialize`](crate::registry::TypeTraitSerialize)
/// - [`TypeTraitDeserialize`](crate::registry::TypeTraitDeserialize)
///
/// They provide some methods similar to the original trait, but the param type changed to reflection type.
///
/// The TypeTrait generated by [`reflect_trait`] is prefixed with `Reflect`
/// because they only provide three fixed conversion methods `get`, `get_mut` and `get_boxed`,
/// See more infomation in [`reflect_trait` macro attribute](crate::derive::reflect_trait).
///
/// # Implementation
///
/// ## Use [`#[reflect_trait]`](crate::derive::reflect_trait) macro
///
/// ```
/// use vc_reflect::{derive::reflect_trait, registry::FromType};
///
/// #[reflect_trait]
/// trait MyDisplay {
///     fn display(&self) { /* ... */ }
/// }
///
/// impl MyDisplay for i32{}
///
/// let reflect_trait = <ReflectMyDisplay as FromType<i32>>::from_type();
/// ```
///
/// ## Manually
///
/// ```
/// use vc_reflect::{derive::TypePath, registry::TypeTrait};
///
/// #[derive(Clone, TypePath)]
/// struct K{ /* ... */ }
///
/// let k = K{ /* ... */ };
/// let type_trait: &dyn TypeTrait = &k;
/// ```
///
/// See the [crate-level documentation] for more information on type_trait and type_meta.
///
/// [`reflect_trait`]: crate::derive::reflect_trait
/// [`TypePath`]: crate::info::TypePath
/// [`TypeRegistry`]: crate::registry::TypeRegistry
/// [crate-level documentation]: crate
pub trait TypeTrait: DynamicTypePath + Any + Send + Sync {
    fn clone_type_trait(&self) -> Box<dyn TypeTrait>;
}

impl<T: Clone + TypePath + Any + Send + Sync> TypeTrait for T {
    #[inline]
    fn clone_type_trait(&self) -> Box<dyn TypeTrait> {
        Box::new(self.clone())
    }
}

impl dyn TypeTrait {
    /// Returns `true` if the underlying value is of type `T`.
    ///
    /// Note that this is a comparison of its own type,
    /// not the target type that implemented this trait.
    #[inline(always)]
    pub fn is<T: Any>(&self) -> bool {
        self.type_id() == TypeId::of::<T>()
    }

    /// Downcasts the value to type `T` by reference.
    #[inline(always)]
    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {
        <dyn Any>::downcast_ref(self)
    }

    /// Downcasts the value to type `T` by mutable reference.
    #[inline(always)]
    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {
        <dyn Any>::downcast_mut(self)
    }
}

impl core::fmt::Debug for dyn TypeTrait {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(DynamicTypePath::reflect_type_name(self))
    }
}
