use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::{Attribute, ItemTrait, Token, parse::Parse, parse_macro_input};

struct TraitInfo {
    item_trait: ItemTrait,
}

impl Parse for TraitInfo {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let attrs = input.call(Attribute::parse_outer)?;
        let lookahead = input.lookahead1();
        if lookahead.peek(Token![pub]) || lookahead.peek(Token![trait]) {
            let mut item_trait: ItemTrait = input.parse()?;
            item_trait.attrs = attrs;
            Ok(TraitInfo { item_trait })
        } else {
            Err(lookahead.error())
        }
    }
}

/// A trait attribute macro that allows a reflected type to be downcast to a trait object.
///
/// This generates a struct that takes the form `ReflectMyTrait`. An instance of this struct can then be
/// used to perform the conversion.
pub(crate) fn impl_reflect_trait(input: TokenStream) -> TokenStream {
    use crate::path::fp::{CloneFP, OptionFP, ResultFP};

    let trait_info = parse_macro_input!(input as TraitInfo);
    let item_trait = &trait_info.item_trait;
    let trait_vis = &item_trait.vis;
    let trait_ident = &item_trait.ident;

    // We do not use the `TypeTrait` prefix,
    // because these types only provide type conversion methods.
    let reflect_trait_ident =
        syn::Ident::new(&format!("Reflect{}", item_trait.ident), Span::call_site());

    let struct_doc = format!(
        " A type generated by the #[reflect_trait] macro for the `{trait_ident}` trait.\n\n This allows casting from `dyn Reflect` to `dyn {trait_ident}`.",
    );
    let get_doc = format!(
        " Downcast a `&dyn Reflect` type to `&dyn {trait_ident}`.\n\n If the type cannot be downcast, `None` is returned.",
    );
    let get_mut_doc = format!(
        " Downcast a `&mut dyn Reflect` type to `&mut dyn {trait_ident}`.\n\n If the type cannot be downcast, `None` is returned.",
    );
    let get_box_doc = format!(
        " Downcast a `Box<dyn Reflect>` type to `Box<dyn {trait_ident}>`.\n\n If the type cannot be downcast, this will return `Err(Box<dyn Reflect>)`.",
    );

    let vc_reflect_path = crate::path::vc_reflect();
    let reflect_ = crate::path::reflect_(&vc_reflect_path);
    let typed_ = crate::path::typed_(&vc_reflect_path);
    let macro_utils_ = crate::path::macro_utils_(&vc_reflect_path);
    let from_type_ = crate::path::from_type_(&vc_reflect_path);
    let type_path_ = crate::path::type_path_(&vc_reflect_path);
    let string_ident = reflect_trait_ident.to_string();

    TokenStream::from(quote! {
        #item_trait

        #[doc = #struct_doc]
        #[derive(#CloneFP)]
        #trait_vis struct #reflect_trait_ident {
            get_func: fn(&dyn #reflect_) -> #OptionFP<&dyn #trait_ident>,
            get_mut_func: fn(&mut dyn #reflect_) -> #OptionFP<&mut dyn #trait_ident>,
            get_boxed_func: fn(#macro_utils_::Box<dyn #reflect_>) -> #ResultFP<#macro_utils_::Box<dyn #trait_ident>, #macro_utils_::Box<dyn #reflect_>>,
        }

        impl #type_path_ for #reflect_trait_ident {
            #[inline]
            fn type_path() -> &'static str {
                ::core::concat!( ::core::module_path!(), "::", #string_ident )
            }

            #[inline]
            fn type_name() -> &'static str {
                #string_ident
            }

            #[inline]
            fn type_ident() -> &'static str {
                #string_ident
            }

            #[inline]
            fn module_path() -> #OptionFP<&'static str> {
                #OptionFP::Some( ::core::module_path!() )
            }
        }

        impl #reflect_trait_ident {
            #[doc = #get_doc]
            #[inline]
            pub fn get<'a>(&self, reflect_value: &'a dyn #reflect_) -> #OptionFP<&'a dyn #trait_ident> {
                (self.get_func)(reflect_value)
            }

            #[doc = #get_mut_doc]
            #[inline]
            pub fn get_mut<'a>(&self, reflect_value: &'a mut dyn #reflect_) -> #OptionFP<&'a mut dyn #trait_ident> {
                (self.get_mut_func)(reflect_value)
            }

            #[doc = #get_box_doc]
            #[inline]
            pub fn get_boxed(&self, reflect_value: #macro_utils_::Box<dyn #reflect_>) -> #ResultFP<#macro_utils_::Box<dyn #trait_ident>, #macro_utils_::Box<dyn #reflect_>> {
                (self.get_boxed_func)(reflect_value)
            }
        }

        impl<T: #trait_ident + #reflect_ + #typed_> #from_type_<T> for #reflect_trait_ident {
            fn from_type() -> Self {
                Self {
                    get_func: |reflect_value| {
                        <dyn #reflect_>::downcast_ref::<T>(reflect_value).map(|value| value as &dyn #trait_ident)
                    },
                    get_mut_func: |reflect_value| {
                        <dyn #reflect_>::downcast_mut::<T>(reflect_value).map(|value| value as &mut dyn #trait_ident)
                    },
                    get_boxed_func: |reflect_value| {
                        <dyn #reflect_>::downcast::<T>(reflect_value).map(|value| value as #macro_utils_::Box<dyn #trait_ident>)
                    }
                }
            }
        }
    })
}
